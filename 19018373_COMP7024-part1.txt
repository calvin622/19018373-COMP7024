; Assembly language demonstration program

; Build either with the automatic build script:
; "build_asm_vX.sh coursework_1_demo.asm"
; OR
; Assemble command:
; "nasm -g -f elf64 -o coursework_1_demo.o coursework_1_demo.asm"
; Link command:
; "gcc coursework_1_demo.o -no-pie -o coursework_1_demo"
; Executable generated is: "coursework_1_demo"
; Can be run with: "./coursework_1_demo"

; This include line is an absolute path to the I/O library. You may wish to change it to suit your own file system.
%include "/home/malware/asm/joey_lib_io_v9_release.asm"

; "global main" defines the entry point of the executable upon linking.
; In other words, "main" defines the point in the code from which the final executable starts execution.
global main

; The ".data" section is where initialised data in memory is defined. This is where we define strings and other predefined data.
; This section is read/write but NOT executable. If it were executable, someone could modify the data to be malicious executable code and then execute it.
; We don't want that! See "Data Execution Prevention (DEP)".
; "db" means "Define Byte", which allocates 1 byte.
; We could also use:
; "dw" = "Define Word", which allocates 2 bytes
; "dd" = "Define Doubleword", which allocates 4 bytes
; "dq" = "Define Quadword, which allocates 8 bytes
section .data
    str_main_menu db 10,\
                            "Main Menu", 10,\
                            " 1. Add User", 10,\
                            " 2. Add Badger", 10,\
                            " 3. List All Users", 10, \
                            " 4. List All BAdgers", 10, \
                            " 5. Count Users", 10,\
                            " 6. Exit", 10,\
                            "Please Enter Option 1 - 6", 10, 0
    
    department_question db 10,\
                                "Select the number that corresponds with your department", 10,\
                                " 1. Park Keeper", 10,\
                                " 2. Gift Shop", 10,\
                                " 3. Cafe", 10, \
                                "Please Enter Option 1 - 3", 10, 0
                                
    homesett_question db 10,\
                                "Select the number that corresponds with badger home sett", 10,\
                                " 1. Settfield", 10,\
                                " 2. Badgerton", 10,\
                                " 3. Stripeville", 10, \
                                "Please Enter Option 1 - 3", 10, 0
    ; Note - after each string we add bytes of value 10 and zero (decimal). These are ASCII codes for linefeed and NULL, respectively.
    ; The NULL is required because we are using null-terminated strings. The linefeed makes the console drop down a line, which saves us having to call "print_nl_new" function separately.
    ; In fact, some strings defined here do not have a linefeed character. These are for occations when we don't want the console to drop down a line when the program runs.
    str_program_exit db "Program exited normally.", 10, 0
    str_option_selected db "Option selected: ", 0
    str_invalid_option db "Invalid option, please try again.", 10, 0
    str_enter_surname db "Enter surname:", 10, 0
    str_enter_forename db "Enter forename:", 10, 0
    str_enter_salary db "Enter salary:", 10, 0
    str_enter_year db "Enter starting year:", 10, 0
    str_enter_id db "Enter ID (must be 7 digits long and between 1000000 - 9999999):", 10, 0
    str_enter_email db "Enter email:", 10, 0
    str_array_full db "Can't add - storage full.", 10, 0
    str_number_of_users db "Number of users: ", 0
    str_error db "Error", 0
    
    str_enter_badger_name db "Enter Badger Name:", 10, 0
    str_enter_sex db "Enter Badger Sex (M or F):", 10, 0
    str_enter_birth_month db "Enter Month of Birth as a number (1=Januaryâ€¦12=December):", 10, 0
    str_enter_birth_year db "Enter Birth Year:", 10, 0
    str_enter_mass db "Enter Mass in Kg:", 10, 0
    str_enter_stripes db "Enter amount of stripes (0 - 255):", 10, 0
    str_enter_badger_id db "Enter ID (must be 6 digits long and between 100000 - 999999):", 10, 0
  
    
    email db "@jnz.co.uk", 0
    park_keeper db "Park Keeper", 0
    gift_shop db "Gift Shop", 0
    cafe db "Cafe", 0
    
    settfield db "settfield", 0
    badgerton db "badgerton", 0
    stripeville db "stripeville", 0

    ; Here we define the size of the block of memory that we want to reserve to hold the users' details
    ; A user record stores the following fields:
    ; forename = 64 bytes (string up to 63 characters plus a null-terminator)
    ; surname = 64 bytes (string up to 63 characters plus a null-terminator)
    ; salary = 2 byte (we're assuming that we don't have any users aged over 255 years old. Although if we entered Henry IV, this may be a problem!)
    ; year = 2 byte (we're assuming that we don't have any users aged over 255 years old. Although if we entered Henry IV, this may be a problem!)
    ; User ID = 4 bytes (string up to 63 characters plus a null terminator)
    ; department = 12 bytes
    ; email = 64 bytes

    ; Total size of user record is therefore 64+64+64+2+2 = 136 bytes
    size_user_record equ 213
    size_badger_record equ 93 ; 1+4+64+12+1+1+1+1+2+4 = 90
    max_num_users equ 100 ; 100 users maximum in array (we can make this smaller in debugging for testing array limits etc.)
    max_num_badgers equ 500 ; 100 users maximum in array (we can make this smaller in debugging for testing array limits etc.)
    size_users_array equ size_user_record*max_num_users ; This calculation is performed at build time and is therefore hard-coded in the final executable.
    size_badger_array equ size_badger_record*max_num_badgers ; This calculation is performed at build time and is therefore hard-coded in the final executable.
    ; We could have just said something like "size_users_array equ 19300". However, this is less human-readable and more difficult to modify the number of users / user record fields.
    ; The compiled code would be identical in either case.
    
    current_number_of_users dq 0 ; this is a variable in memory which stores the number of users which have currently been entered into tthe array.
    current_number_of_badgers dq 0 ; this is a variable in memory which stores the number of users which have currently been entered into tthe array.
    current_year equ 2023
    
; The ".bss" section is where we define uninitialised data in memory. Unlike the .data section, this data does not take up space in the executable file (apart from its definition, of course).
; Upon execution, this data is initialised to zero. This section is read/write but NOT executable, for the same reasons as .data section above.
; The syntax differs slightly from that of the .data section:
; resb = Reserve a Byte (1 byte)
; resw = Reserve a Word (2 bytes)
; resd = Reserve a Doubleword (4 bytes)
; resq = Reserve a Quadword (8 bytes)
section .bss
    users: resb size_users_array; space for max_num_users user records. "resb
    temp_users: resb size_user_record
    
    badgers: resb size_badger_array; space for max_num_users user records. "resb
    temp_badgers: resb size_badger_record

; The ".text" section contains the executable code. This area of memory is generally read-only so that the code cannot be mucked about with at runtime by a mischievous user.
section .text

add_user:
; Adds a new user into the array
; We need to check that the array is not full before calling this function. Otherwise buffer overflow will occur.
; No parameters (we are using the users array as a global)
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, temp_users ; base address of temp users array
    
    ; get user id
    mov rdi, str_enter_id
    call print_string_new ; print message
    call read_uint_new ; get input from user
    cmp rax, 9999999
    ja .error
    cmp rax, 1000000
    jl .error
    ; inputted number is now in the RAX register
    mov rsi, rax
    mov rdi, 1
    call unique_id
    cmp rax, -1
    je .error
    inc rcx ; save space for 'p'
    mov DWORD[rcx], eax ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get forename
    add rcx, 4 ; move along by 1 byte (which is the size of age field)
    mov rdi, str_enter_forename
    call print_string_new ; print message
    call read_string_new ; get input from user
    mov rbx, rax
    call string_length
    cmp rax, 63 ; check if string is larger than 63 characters, allowing space for null
    ja .error
    mov rsi, rbx ; address of new string into rsi
    mov rdi, rcx ; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
    
    ; get surname
    add rcx, 64 ; move along by 64 bytes (which is the size reserved for the forename string)
    mov rdi, str_enter_surname
    call print_string_new ; print message
    call read_string_new ; get input from user
    mov rbx, rax
    call string_length
    cmp rax, 63 ; check if string is larger than 63 characters, allowing space for null
    ja .error
    mov rsi, rbx ; address of new string into rsi
    mov rdi, rcx ; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
    
    ; get start year
    add rcx, 64 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov rdi, str_enter_year
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    cmp rax, current_year
    ja .error
    mov WORD[rcx], ax ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get salary
    add rcx, 2 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov rdi, str_enter_salary
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    cmp rax, 65535 ; max int we have reserved space for
    ja .error
    mov WORD[rcx], ax ; we are only going to copy the least significant 2 bytes of RAX (ax), because thats what we have reserved earlier
    
    ;get department
    mov rdi, department_question
    call print_string_new ; print message
    call read_int_new ;read in option
    cmp rax, 1 ;cmp option
    jne .check_gift_shop
    mov rsi, park_keeper ; add string to rsi ready for copy into array
    jmp .add_department
   .check_gift_shop:
    cmp rax, 2
    jne .check_cafe
    mov rsi, gift_shop
    jmp .add_department
   .check_cafe:
    cmp rax, 3
    jne .department_error
    mov rsi, cafe
    jmp .add_department
   .department_error:
    mov rax, -2
    jmp .error
   .add_department:
    add rcx, 2 
    mov rdi, rcx; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
      
    ; get email
    mov rdi, str_enter_email
    call print_string_new ; print message
    call read_string_new
    mov rbx, rax
    call string_length
    cmp rax, 63 ; check if string is larger than 63 characters, allowing space for null
    ja .error
    mov rsi, rbx
    lea rsi, [rbx + rax - 10];go the last 10 bytes of the user string and check its "@jnz.co.uk"
    lea rdi, [email]
    call strings_are_equal
    cmp rax, 1
    jne .error
    add rcx, 12
    mov rsi, rbx
    mov rdi, rcx ; address of new string into rsi
    call copy_string ; copy string from input buffer into user record in array
    
    
    ; copy temp array into array 
    mov rcx, users ; base address of users array
    mov rsi, temp_users
    mov rax, QWORD[current_number_of_users] ; value of current_number_of_users
    mov rbx, size_user_record ; size_user_record is an immediate operand since it is defined at build time.
    mul rbx ; calculate address offset (returned in RAX).
    ; RAX now contains the offset of the next user record. We need to add it to the base address of users record to get the actual address of the next empty user record.
    add rcx, rax ; calculate address of next unused users record in array
    ; RCX now contins address of next empty user record in the array, so we can fill up the data.
    mov BYTE[rcx], 0x70 ; move char 'p' into start of array, used for ID
    mov rdx, rcx ; move array into rdx so we can use rcx as counter
    inc rsi ; move 1 byte along in temp_user array becasue we save space for 'p' 
    lea rdi, [rdx + 1] ; load users _array, move 1 byte along becasue we save space for 'p'
    mov rcx, 212 ; bytes to copy
   .copy_loop:
    movsb
    loop .copy_loop
   
    ; clear temp array here
    mov rdi, temp_users
    mov rcx, size_user_record
    xor al, al
    rep stosb
    

    inc QWORD[current_number_of_users] ; increment our number of users counter, since we have just added a record into the array.
    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx 
    ret ; End function add_user
    
   .error:
   ; clear temp array here
    mov rdi, temp_users
    mov rcx, size_user_record
    xor al, al
    rep stosb
    
    mov rdi, str_error
    call print_string_new
    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx 
    ret ; End function add_user
    
add_badger:
; Adds a new user into the array
; We need to check that the array is not full before calling this function. Otherwise buffer overflow will occur.
; No parameters (we are using the users array as a global)
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, temp_badgers ; base address of temp users array
    
    ; get badger id
    mov rdi, str_enter_badger_id
    call print_string_new ; print message
    call read_uint_new ; get input from user
    cmp rax, 999999
    ja .error
    cmp rax, 100000
    jl .error
    ; inputted number is now in the RAX register
    mov rsi, rax
    mov rdi, 2
    call unique_id
    cmp rax, -1
    je .error
    inc rcx ; save space for 'b'
    mov DWORD[rcx], eax ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get badger name
    add rcx, 4 ; move along by 1 byte (which is the size of age field)
    mov rdi, str_enter_badger_name
    call print_string_new ; print message
    call read_string_new ; get input from user
    mov rbx, rax
    call string_length
    cmp rax, 63 ; check if string is larger than 63 characters, allowing space for null
    ja .error
    mov rsi, rbx ; address of new string into rsi
    mov rdi, rcx ; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
    
    ;get home sett
    mov rdi, homesett_question
    call print_string_new ; print message
    call read_int_new ;read in option
    cmp rax, 1 ;cmp option
    jne .check_badgerton
    mov rsi, settfield; add string to rsi ready for copy into array
    jmp .add_homesett
   .check_badgerton:
    cmp rax, 2
    jne .check_stripeville
    mov rsi, badgerton
    jmp .add_homesett
   .check_stripeville:
    cmp rax, 3
    jne .homesett_error
    mov rsi, stripeville
    jmp .add_homesett
   .homesett_error:
    mov rax, -2
    jmp .error
   .add_homesett:
    add rcx, 64 
    mov rdi, rcx; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
    
    ; get badger mass (Kg)
    
    mov rdi, str_enter_mass
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    add rcx, 12 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov BYTE[rcx], al ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get amount of stripes
    add rcx, 1 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov rdi, str_enter_stripes
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    mov BYTE[rcx], al ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get badger sex
    add rcx, 1 ; move along by 1 byte (which is the size of age field)
    mov rdi, str_enter_sex
    call print_string_new ; print message
    call read_string_new ; get input from user
    mov rsi, rax ; address of new string into rsi
    mov rdi, rcx ; address of memory slot into rdi
    call copy_string ; copy string from input buffer into user record in array
    
    ; get birth month
    add rcx, 2 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov rdi, str_enter_birth_month
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    mov BYTE[rcx], al ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get birth year
    add rcx, 1 ; move along by 64 bytes (which is the size reserved for the surname string)
    mov rdi, str_enter_birth_year
    call print_string_new ; print message
    call read_uint_new ; get input from user
    ; inputted number is now in the RAX register
    mov WORD[rcx], ax ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    ; get assigned keeper id
    mov rdi, str_enter_id
    call print_string_new ; print message
    call read_uint_new ; get input from user
    cmp rax, 9999999
    ja .error
    cmp rax, 1000000
    jl .error
    ; inputted number is now in the RAX register
    mov rsi, rax
    mov rdi, 1
    call unique_id
    cmp rax, -1
    jne .error ; jump if valid id was not found
    add rcx, 2
    mov BYTE[rcx], 0x70 ; move char 'p' into start of array, used for ID
    inc rcx
    mov DWORD[rcx], eax ; we are only going to copy the least significant byte of RAX (AL), because our age field is only one byte
    
    
    
   

     
    ; copy temp array into array 
    mov rcx, badgers ; base address of users array
    mov rsi, temp_badgers
    mov rax, QWORD[current_number_of_badgers] ; value of current_number_of_users
    mov rbx, size_badger_record ; size_user_record is an immediate operand since it is defined at build time.
    mul rbx ; calculate address offset (returned in RAX).
    ; RAX now contains the offset of the next user record. We need to add it to the base address of users record to get the actual address of the next empty user record.
    add rcx, rax ; calculate address of next unused users record in array
    ; RCX now contins address of next empty user record in the array, so we can fill up the data.
    mov BYTE[rcx], 0x70 ; move char 'p' into start of array, used for ID
    mov rdx, rcx ; move array into rdx so we can use rcx as counter
    inc rsi ; move 1 byte along in temp_user array becasue we save space for 'p' 
    lea rdi, [rdx + 1] ; load users _array, move 1 byte along becasue we save space for 'p'
    mov rcx, 92 ; bytes to copy
   .copy_loop:
    movsb
    loop .copy_loop
   
    ; clear temp array here
    mov rdi, temp_badgers
    mov rcx, size_badger_record
    xor al, al
    rep stosb
    

    inc QWORD[current_number_of_badgers] ; increment our number of users counter, since we have just added a record into the array.
    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx 
    ret ; End function add_user
    
   .error:
   ; clear temp array here
    mov rdi, temp_badgers
    mov rcx, size_badger_record
    xor al, al
    rep stosb
    
    mov rdi, str_error
    call print_string_new
    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx 
    ret ; End function add_user
    
    
    
    
list_all_users:
; Takes no parameters (users is global)
; Lists full details of all users in the array
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi

    lea rsi, [users] ; load base address of the users array into RSI. In other words, RSI points to the users array.
    mov rcx, [current_number_of_users] ; we will use RCX for the counter in our loop

    ;this is the start of our loop
  .start_loop:
    cmp rcx, 0
    je .finish_loop ; if the counter is a zero then we have finished our loop
    ;display the user record
    mov rdi, [rsi] ; put the pointer to the current record in RDI, to pass to the print_string_new function
    
    ;display ID
    call print_char_new
    mov edi, [rsi + 1] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    call print_uint_new
    call print_nl_new
    
    ;display forename
    lea rdi, [rsi + 5] ; move the pointer along by 64 bytes from the base address of the record (the size of the forename string)
    call print_string_new
    mov rdi,' ' ; space character, between forename and surname.
    call print_char_new ; print a space
    
    ;display surname
    lea rdi, [rsi + 69] ; move the pointer along by 64 bytes from the base address of the record (the size of the forename string)
    call print_string_new
    call print_nl_new
    
    ;display year
    movzx rdi, WORD[rsi + 133] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
    mov rbx, rdi  
    call print_uint_new ; print the age
    call print_nl_new
    
    ;display salary
    movzx rdi, WORD[rsi + 135] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings.
    mov rax, current_year
    sub rax, rbx                                       ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
    imul rax, 200
    add rdi, rax
    call print_uint_new ; print the age
    call print_nl_new
    
    ; display department
    lea rdi, [rsi + 137] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    call print_string_new
    call print_nl_new
    
    ; display email
    lea rdi, [rsi + 149] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    call print_string_new
    call print_nl_new
    
    
    ; next user
    call print_nl_new
    add rsi, size_user_record ; move the address to point to the next record in the array
    dec rcx ; decrement our counter variable
    jmp .start_loop ; jump back to the start of the loop (unconditional jump)
  .finish_loop:

    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx
    ret ; End function list_all_users
    
list_all_badgers:
; Takes no parameters (users is global)
; Lists full details of all users in the array
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi

    lea rsi, [badgers] ; load base address of the users array into RSI. In other words, RSI points to the users array.
    mov rcx, [current_number_of_badgers] ; we will use RCX for the counter in our loop

    ;this is the start of our loop
  .start_loop:
    cmp rcx, 0
    je .finish_loop ; if the counter is a zero then we have finished our loop
    ;display the user record
    
    
    ;display ID
    movzx edi, BYTE[rsi] ; put the pointer to the current record in RDI, to pass to the print_string_new function
    call print_char_new ; print 'b'
    mov edi, [rsi + 1] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    call print_uint_new
    call print_nl_new
    
    ;display name
    lea rdi, [rsi + 5] ; move the pointer along by 64 bytes from the base address of the record (the size of the forename string)
    call print_string_new
    call print_nl_new
    
    ;display home sett
    lea rdi, [rsi + 69] ; move the pointer along by 64 bytes from the base address of the record (the size of the forename string)
    call print_string_new
    call print_nl_new
    
    ;display mass
    movzx rdi, BYTE[rsi + 81] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
   
    call print_uint_new ; print the age
    call print_nl_new
    
    ;display stripes
    movzx rdi, BYTE[rsi + 82] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
   
    call print_uint_new ; print the age
    call print_nl_new
    
    ;display sex
    lea rdi, [rsi + 83] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
   
    call print_string_new ; print the age
    call print_nl_new
    
    ;display birth month
    movzx rdi, BYTE[rsi + 85] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
   
    call print_uint_new ; print the age
    call print_nl_new
    
    ;display birth year
    movzx rdi, WORD[rsi + 86] ; dereferrence [RSI + 128] into RDI. 128 bytes is the combined size of the forename and surname strings. ;We need to zero extend (movzx) because the age in memory is one byte and the RDI register is 8 bytes.
   
    call print_uint_new ; print the age
    call print_nl_new
    
   
    ;display ID
    movzx edi, BYTE[rsi + 88] ; put the pointer to the current record in RDI, to pass to the print_string_new function
    call print_char_new
    mov edi, [rsi + 89] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    call print_uint_new
    call print_nl_new
    
   
    
    
    
       
    ; next badger
    call print_nl_new
    add rsi, size_badger_record ; move the address to point to the next record in the array
    dec rcx ; decrement our counter variable
    jmp .start_loop ; jump back to the start of the loop (unconditional jump)
    
    
  .finish_loop:

    pop rsi    
    pop rdi    
    pop rdx
    pop rcx
    pop rbx
    ret ; End function list_all_users
    
display_number_of_users:
; No parameters
; Displays number of users in list (to STDOUT)
    push rdi
    mov rdi, str_number_of_users
    call print_string_new
    mov rdi, [current_number_of_users]
    call print_uint_new
    call print_nl_new
    pop rdi    
    ret ; End function display_number_of_users

display_main_menu:
; No parameters
; Prints main menu
    push rdi
    mov rdi, str_main_menu
    call print_string_new
    pop rdi
    ret ; End function display_main_menu

string_length:
    push rcx
    push rbx
    push rdi
    sub rcx,rcx			; this sets the max size to look for to be
    not rcx			; the maximum memory size
    mov al, 0 ; We want to look for the byte 0, null terminator
    mov rdi, rbx		; set the start of the string
    cld
    repne scasb			; search
    sub rdi, rbx		; we need to take off the start of the string
    dec rdi			; and allow for the null terminator
    mov rax, rdi
    
    pop rdi
    pop rbx
    pop rcx
    ret
    
unique_id:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
      
    mov rbx, rsi ;move id into rbx
    cmp rdi, 1
    je .staff_loop
    lea rsi, [badgers] ; load base address of the users array into RSI. In other words, RSI points to the users array.
    mov rcx, [current_number_of_badgers] ; we will use RCX for the counter in our loop
    mov rdx, size_badger_record
    jmp .check_id
   .staff_loop:
    lea rsi, [users] ; load base address of the users array into RSI. In other words, RSI points to the users array.
    mov rcx, [current_number_of_users] ; we will use RCX for the counter in our loop
    mov rdx, size_user_record
   .check_id:
    cmp rcx, 0
    je .finish_loop ; if the counter is a zero then we have finished our loop
    ;check ID
    mov edi, [rsi + 1] ; move the pointer along by 129 bytes from the base address of the record (combined size of the forename and surname strings, and age) 
    cmp edi, ebx
    je .found_match

    ; next user
    add rsi, rdx ; move the address to point to the next record in the array
    dec rcx ; decrement our counter variable
    jmp .check_id ; jump back to the start of the loop (unconditional jump)
    
  .found_match:
    mov rax, -1
  .finish_loop:

    pop rsi    
    pop rdi
    pop rdx    
    pop rcx
    pop rbx
    ret ; End function list_all_users
    

main: 
    mov rbp, rsp; for correct debugging
    ; We have these three lines for compatability only
    push rbp
    mov rbp, rsp
    sub rsp,32
    
  .menu_loop:
    call display_main_menu
    call read_int_new ; menu option (number) is in RAX
    mov rdx, rax ; store value in RDX
    ; Print the selected option back to the user
    mov rdi, str_option_selected
    call print_string_new
    mov rdi, rdx
    call print_int_new
    call print_nl_new
    ; Now jump to the correct option
    cmp rdx, 1
    je .option_1
    cmp rdx, 2
    je .option_2
    cmp rdx, 3
    je .option_3
    cmp rdx, 4
    je .option_4
    cmp rdx, 5
    je .option_5
    cmp rdx, 6
    je .option_6
    ; If we get here, the option was invalid. Display error and loop back to input option.
    mov rdi, str_invalid_option
    call print_string_new
    jmp .menu_loop

  .option_1: ; 1. Add User
    ; Check that the array is not full    
    mov rdx, [current_number_of_users] ; This is indirect, hence [] to dereference
    cmp rdx, max_num_users ; Note that max_num_users is an immediate operand since it is defined at build-time
    jl .array_is_not_full ; If current_number_of_users < max_num_users then array is not full, so add new user.
    mov rdi, str_array_full ; display "array is full" message and loop back to main menu
    call print_string_new
    jmp .menu_loop
  .array_is_not_full:
    call add_user
    jmp .menu_loop
    
  .option_2: ; 1. Add Badger
    ; Check that the array is not full    
    mov rdx, [current_number_of_badgers] ; This is indirect, hence [] to dereference
    cmp rdx, max_num_badgers ; Note that max_num_users is an immediate operand since it is defined at build-time
    jl .badger_array_is_not_full ; If current_number_of_users < max_num_users then array is not full, so add new user.
    mov rdi, str_array_full ; display "array is full" message and loop back to main menu
    call print_string_new
    jmp .menu_loop
  .badger_array_is_not_full:
    call add_badger
    jmp .menu_loop
    
  .option_3: ; 2. List All Users
    call display_number_of_users
    call print_nl_new
    call list_all_users
    jmp .menu_loop
    
  .option_4: ; 2. List All Badgers
    call display_number_of_users
    call print_nl_new
    call list_all_badgers
    jmp .menu_loop
    
  .option_5: ; 3. Count Users
    call display_number_of_users
    jmp .menu_loop 
    
  .option_6: ; 4. Exit
    ; In order to exit the program we just display a message and return from the main function.
    mov rdi, str_program_exit
    call print_string_new

    xor rax, rax ; return zero
    ; and these lines are for compatability
    add rsp, 32
    pop rbp
    
    ret ; End function main
